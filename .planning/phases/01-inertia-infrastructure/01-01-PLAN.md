---
phase: 01-inertia-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scrapegrape/scrapegrape/settings.py
  - scrapegrape/scrapegrape/urls.py
  - scrapegrape/publishers/views.py
  - scrapegrape/templates/base.html
  - sgui/src/main.tsx
  - sgui/src/Pages/Debug/InertiaTest.tsx
  - sgui/package.json
  - pyproject.toml
autonomous: false

must_haves:
  truths:
    - "User can load /_debug/inertia/ and see a React component rendered via Inertia with props from Django"
    - "Root route / continues to work identically as the existing template-based view"
    - "Django admin at /admin/ loads without interference from Inertia middleware"
    - "InertiaMiddleware appears in Django's middleware stack after CsrfViewMiddleware"
  artifacts:
    - path: "scrapegrape/scrapegrape/settings.py"
      provides: "Inertia middleware and INERTIA_LAYOUT configuration"
      contains: "InertiaMiddleware"
    - path: "scrapegrape/scrapegrape/urls.py"
      provides: "Debug smoke test route"
      contains: "_debug/inertia/"
    - path: "scrapegrape/publishers/views.py"
      provides: "Inertia smoke test view function"
      contains: "inertia_smoke_test"
    - path: "scrapegrape/templates/base.html"
      provides: "Inertia root div via block inertia"
      contains: "block inertia"
    - path: "sgui/src/main.tsx"
      provides: "createInertiaApp setup with CSRF config"
      contains: "createInertiaApp"
    - path: "sgui/src/Pages/Debug/InertiaTest.tsx"
      provides: "Smoke test React page component"
      contains: "InertiaTest"
  key_links:
    - from: "scrapegrape/publishers/views.py"
      to: "sgui/src/Pages/Debug/InertiaTest.tsx"
      via: "Inertia render() component name 'Debug/InertiaTest'"
      pattern: "render.*Debug/InertiaTest"
    - from: "sgui/src/main.tsx"
      to: "sgui/src/Pages/**/*.tsx"
      via: "import.meta.glob page resolution"
      pattern: "import\\.meta\\.glob.*Pages"
    - from: "scrapegrape/scrapegrape/settings.py"
      to: "scrapegrape/templates/base.html"
      via: "INERTIA_LAYOUT setting pointing to base.html"
      pattern: "INERTIA_LAYOUT.*base\\.html"
    - from: "sgui/src/main.tsx"
      to: "axios CSRF defaults"
      via: "Axios xsrfHeaderName/xsrfCookieName config"
      pattern: "xsrfHeaderName.*X-CSRFToken"
---

<objective>
Install and configure Inertia.js on both the Django backend and React frontend, then validate with a smoke test page at /_debug/inertia/.

Purpose: Establish the Inertia infrastructure that all subsequent phases depend on. Proves Django can render React components via Inertia with props, CSRF is configured for future POST requests, and existing routes continue working.

Output: Working Inertia setup validated by smoke test page rendering a React component with Django-provided props.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-inertia-infrastructure/01-RESEARCH.md
@scrapegrape/scrapegrape/settings.py
@scrapegrape/scrapegrape/urls.py
@scrapegrape/publishers/views.py
@scrapegrape/templates/base.html
@sgui/src/main.tsx
@sgui/vite.config.ts
@sgui/package.json
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Inertia packages and configure Django backend</name>
  <files>
    pyproject.toml
    scrapegrape/scrapegrape/settings.py
    scrapegrape/scrapegrape/urls.py
    scrapegrape/publishers/views.py
  </files>
  <action>
**Install Python package:**

Run `uv add inertia-django` from the project root to add the inertia-django package.

**Update settings.py** (`scrapegrape/scrapegrape/settings.py`):

1. Add `'inertia'` to INSTALLED_APPS after `'rest_framework'` (before the project apps):
```python
INSTALLED_APPS = [
    # ... existing django apps ...
    "django_vite",
    "django_object_actions",
    "django_tasks",
    "django_tasks.backends.database",
    "rest_framework",
    "inertia",          # NEW
    "ingestion",
    "publishers",
]
```

2. Add InertiaMiddleware to MIDDLEWARE. Place it AFTER CsrfViewMiddleware and BEFORE AuthenticationMiddleware:
```python
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "inertia.middleware.InertiaMiddleware",  # NEW: After CSRF, before Auth
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]
```

3. Add INERTIA_LAYOUT setting at the bottom of the file (after DJANGO_VITE config):
```python
# Inertia configuration
INERTIA_LAYOUT = 'base.html'
```

**Add smoke test view** to `scrapegrape/publishers/views.py`:

Add this function AFTER the existing `table` view. Import `inertia.render` as `inertia_render` to avoid collision with `django.shortcuts.render`:
```python
from inertia import render as inertia_render

def inertia_smoke_test(request):
    """
    Temporary smoke test: proves Inertia renders a React component with Django props.
    Lives at /_debug/inertia/ — remove in Phase 5 cleanup.
    """
    return inertia_render(request, 'Debug/InertiaTest', props={
        'message': 'Inertia is working!',
        'timestamp': '2026-02-12',
    })
```

**Update urls.py** (`scrapegrape/scrapegrape/urls.py`):

Add the debug route. Place it BEFORE the existing routes so it gets its own explicit URL. The root route `/` must remain exactly as-is:
```python
from django.contrib import admin
from django.urls import path

import publishers.views

urlpatterns = [
    path("admin/", admin.site.urls),
    path("_debug/inertia/", publishers.views.inertia_smoke_test, name="debug-inertia"),
    path("", publishers.views.table, name="table"),
]
```

Note: Move admin/ before the debug route for clarity. The existing root route stays last and unchanged.
  </action>
  <verify>
Run from scrapegrape/ directory:
1. `uv run python manage.py check` — should report "System check identified no issues"
2. `uv run python -c "from inertia import render; print('inertia-django imported OK')"` — should print success message
3. Verify InertiaMiddleware position: `grep -n "InertiaMiddleware" scrapegrape/scrapegrape/settings.py` — should appear after CsrfViewMiddleware line
4. Verify INERTIA_LAYOUT: `grep "INERTIA_LAYOUT" scrapegrape/scrapegrape/settings.py` — should show 'base.html'
5. Verify route: `grep "_debug/inertia" scrapegrape/scrapegrape/urls.py` — should show the debug route
  </verify>
  <done>
inertia-django installed and importable. INSTALLED_APPS contains 'inertia'. InertiaMiddleware in MIDDLEWARE after CsrfViewMiddleware. INERTIA_LAYOUT set to 'base.html'. Smoke test view exists in publishers/views.py. Debug route registered at /_debug/inertia/. Existing root route "/" and admin route "/admin/" unchanged. `manage.py check` passes with no issues.
  </done>
</task>

<task type="auto">
  <name>Task 2: Install frontend packages, configure createInertiaApp, and update base template</name>
  <files>
    sgui/package.json
    sgui/src/main.tsx
    sgui/src/Pages/Debug/InertiaTest.tsx
    scrapegrape/templates/base.html
  </files>
  <action>
**Install npm packages:**

Run from the `sgui/` directory:
```bash
npm install @inertiajs/react axios
```

This adds @inertiajs/react and axios to sgui/package.json dependencies.

**Replace main.tsx** (`sgui/src/main.tsx`):

Replace the entire file contents. The current file mounts a React app on `#root` using StrictMode. Replace it with createInertiaApp setup that includes CSRF configuration:

```tsx
import { createInertiaApp } from '@inertiajs/react'
import { createRoot } from 'react-dom/client'
import axios from 'axios'
import './index.css'

// Configure CSRF for Django compatibility (INRT-04)
// Makes Axios use Django's cookie/header names instead of its own defaults
axios.defaults.xsrfHeaderName = "X-CSRFToken"
axios.defaults.xsrfCookieName = "csrftoken"

createInertiaApp({
    resolve: name => {
        const pages = import.meta.glob('./Pages/**/*.tsx', { eager: true })
        const page = pages[`./Pages/${name}.tsx`]
        if (!page) {
            throw new Error(`Page not found: ${name}. Available: ${Object.keys(pages).join(', ')}`)
        }
        return page
    },
    setup({ el, App, props }) {
        createRoot(el).render(<App {...props} />)
    },
})
```

Key decisions:
- Import `./index.css` to preserve existing Tailwind styles
- Eager loading (not lazy) per research recommendation — better tree-shaking and build-time error detection
- Error message lists available pages for debugging missing component issues
- No StrictMode wrapper (Inertia manages its own lifecycle)

**Create smoke test page component:**

Create directory `sgui/src/Pages/Debug/` and file `sgui/src/Pages/Debug/InertiaTest.tsx`:

```tsx
interface Props {
    message: string
    timestamp: string
}

export default function InertiaTest({ message, timestamp }: Props) {
    return (
        <div style={{ padding: '2rem', fontFamily: 'sans-serif' }}>
            <h1>Inertia Smoke Test</h1>
            <p><strong>Message from Django:</strong> {message}</p>
            <p><strong>Timestamp:</strong> {timestamp}</p>
            <p style={{ color: 'green', marginTop: '1rem' }}>
                Inertia.js is correctly configured
            </p>
        </div>
    )
}
```

This is a minimal component that displays props passed from the Django smoke test view. Typed with a Props interface. Default export required by Inertia's page resolution.

**Update base template** (`scrapegrape/templates/base.html`):

Replace the `<div id="root">` with `{% block inertia %}{% endblock %}`. The InertiaMiddleware injects a `<div id="app" data-page="...">` into this block for Inertia responses. For non-Inertia responses (like the existing index.html), the block remains empty and child templates can use `extra_body` as before.

Updated base.html:
```html
{% load django_vite %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Scrapegrape{% endblock %}</title>

    {% vite_hmr_client %}
    {% vite_react_refresh %}
    {% vite_asset 'src/main.tsx' %}

    {% block extra_head %}{% endblock %}
</head>
<body>
    {% block inertia %}{% endblock %}

    {% block extra_body %}{% endblock %}
</body>
</html>
```

IMPORTANT: The existing `index.html` template extends base.html and uses `{% block extra_body %}` to embed JSON. It does NOT use the `<div id="root">` — React's App.tsx finds `#root` by ID. Since we're removing `<div id="root">`, the existing index.html template's React initialization via the old main.tsx will break. However, the old main.tsx is being replaced by createInertiaApp in this same task. The existing table view at "/" uses Django's `render()` (not Inertia's `render()`), so InertiaMiddleware will pass it through unchanged. The JSON data will still be embedded via `{% block extra_body %}`.

WAIT — this is a problem. The existing App.tsx mounts on `document.getElementById('root')` via the OLD main.tsx. With the new createInertiaApp, the old App.tsx won't be used at all. The existing "/" view renders index.html which embeds JSON, and App.tsx picks it up. After this change, "/" won't have a working React table because createInertiaApp only renders Inertia page components.

The solution: The existing "/" route will NOT be an Inertia route during Phase 1 (per locked decision: "Root route `/` stays untouched"). But with main.tsx replaced, the React table at "/" will stop working because createInertiaApp doesn't mount on `#root` and doesn't parse embedded JSON.

To preserve existing functionality during Phase 1, we need to keep the old entry point working alongside the new one. Two approaches:

**Approach chosen: Dual entry point.** Keep the existing main.tsx as `main-legacy.tsx` and create the new Inertia entry point as `main.tsx`. Update base.html to use a conditional block — but that adds template complexity.

**Simpler approach: main.tsx detects context.** Have main.tsx check whether it's running in an Inertia context (page data exists) or legacy context (no Inertia data). If `#app[data-page]` exists, run createInertiaApp. Otherwise, fall back to legacy mounting on `#root`.

**Simplest approach (recommended): Keep both mount targets in base.html.** The base template keeps `<div id="root">` for the legacy path AND `{% block inertia %}` for the Inertia path. main.tsx does dual initialization:

```tsx
import { createInertiaApp } from '@inertiajs/react'
import { createRoot } from 'react-dom/client'
import axios from 'axios'
import './index.css'

// Configure CSRF for Django compatibility (INRT-04)
axios.defaults.xsrfHeaderName = "X-CSRFToken"
axios.defaults.xsrfCookieName = "csrftoken"

// Detect whether we're in an Inertia context or legacy context
const inertiaRoot = document.getElementById('app')

if (inertiaRoot && inertiaRoot.dataset.page) {
    // Inertia path: page component resolution
    createInertiaApp({
        resolve: name => {
            const pages = import.meta.glob('./Pages/**/*.tsx', { eager: true })
            const page = pages[`./Pages/${name}.tsx`]
            if (!page) {
                throw new Error(`Page not found: ${name}. Available: ${Object.keys(pages).join(', ')}`)
            }
            return page
        },
        setup({ el, App, props }) {
            createRoot(el).render(<App {...props} />)
        },
    })
} else {
    // Legacy path: existing React app mounted on #root
    import('./App.tsx').then(({ default: App }) => {
        const rootEl = document.getElementById('root')
        if (rootEl) {
            const { StrictMode } = require('react')
            createRoot(rootEl).render(<App />)
        }
    })
}
```

Actually, dynamic import with require is messy. Cleaner version:

```tsx
import { createInertiaApp } from '@inertiajs/react'
import { createRoot } from 'react-dom/client'
import { StrictMode } from 'react'
import axios from 'axios'
import './index.css'

// Configure CSRF for Django compatibility (INRT-04)
axios.defaults.xsrfHeaderName = "X-CSRFToken"
axios.defaults.xsrfCookieName = "csrftoken"

// Detect Inertia context: InertiaMiddleware injects <div id="app" data-page="...">
const inertiaRoot = document.getElementById('app')

if (inertiaRoot?.dataset.page) {
    // Inertia path — render page component from Django's render_inertia() response
    createInertiaApp({
        resolve: name => {
            const pages = import.meta.glob('./Pages/**/*.tsx', { eager: true })
            const page = pages[`./Pages/${name}.tsx`]
            if (!page) {
                throw new Error(
                    `Page not found: ${name}. Available: ${Object.keys(pages).join(', ')}`
                )
            }
            return page
        },
        setup({ el, App, props }) {
            createRoot(el).render(<App {...props} />)
        },
    })
} else {
    // Legacy path — existing template-based React app (Phase 1 coexistence)
    // This branch handles "/" which still uses index.html + json_script embedding
    // Will be removed when "/" is migrated to Inertia in Phase 3
    const legacyRoot = document.getElementById('root')
    if (legacyRoot) {
        import('./App').then(({ default: App }) => {
            createRoot(legacyRoot).render(
                <StrictMode>
                    <App />
                </StrictMode>
            )
        })
    }
}
```

Use this dual-path main.tsx. The dynamic `import('./App')` keeps the legacy App out of the Inertia bundle when tree-shaking runs (Phase 5 will remove this branch entirely).

**Update base.html accordingly** — keep BOTH the `#root` div and the `{% block inertia %}`:

```html
{% load django_vite %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Scrapegrape{% endblock %}</title>

    {% vite_hmr_client %}
    {% vite_react_refresh %}
    {% vite_asset 'src/main.tsx' %}

    {% block extra_head %}{% endblock %}
</head>
<body>
    {% block inertia %}{% endblock %}

    <div id="root"></div>

    {% block extra_body %}{% endblock %}
</body>
</html>
```

The `{% block inertia %}` block is populated by InertiaMiddleware ONLY for Inertia responses. For legacy responses (existing table view), this block stays empty and the `<div id="root">` + `{% block extra_body %}` path works as before.
  </action>
  <verify>
1. Check packages installed: `cd sgui && npm ls @inertiajs/react axios` — both should appear
2. Check main.tsx has createInertiaApp: `grep "createInertiaApp" sgui/src/main.tsx`
3. Check CSRF config: `grep "xsrfHeaderName" sgui/src/main.tsx` — should show "X-CSRFToken"
4. Check page component exists: `ls sgui/src/Pages/Debug/InertiaTest.tsx`
5. Check base.html has inertia block: `grep "block inertia" scrapegrape/templates/base.html`
6. Check base.html still has root div: `grep 'id="root"' scrapegrape/templates/base.html`
7. TypeScript check: `cd sgui && npx tsc --noEmit` — should pass with no errors (or only pre-existing ones)
  </verify>
  <done>
@inertiajs/react and axios installed in sgui/package.json. main.tsx uses createInertiaApp with import.meta.glob page resolution and CSRF configured (xsrfHeaderName="X-CSRFToken", xsrfCookieName="csrftoken"). Pages/Debug/InertiaTest.tsx exists as typed page component with default export. base.html has {% block inertia %} for Inertia responses AND retains #root div for legacy path. Legacy "/" view continues working via dynamic import of App.tsx. TypeScript compiles without new errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Inertia smoke test renders and existing view still works</name>
  <action>Human verification of automated infrastructure setup.</action>
  <what-built>
Inertia.js infrastructure: inertia-django backend adapter with middleware and settings, @inertiajs/react frontend with createInertiaApp and CSRF configuration, smoke test page component, and dual-path entry point preserving existing functionality.
  </what-built>
  <how-to-verify>
Start the development servers if not already running (Django + Vite via Docker compose or manually).

**Test 1: Smoke test page**
1. Navigate to http://localhost:8000/_debug/inertia/
2. Expected: Page loads showing "Inertia Smoke Test" heading, "Message from Django: Inertia is working!", and "Timestamp: 2026-02-12"
3. Check browser console — should have no errors related to Inertia or React

**Test 2: Existing table view**
1. Navigate to http://localhost:8000/
2. Expected: Publisher data table loads exactly as before (sortable, filterable, expandable rows)
3. The page should work identically to before this change

**Test 3: Django admin**
1. Navigate to http://localhost:8000/admin/
2. Expected: Django admin loads normally with all styling intact

**Test 4: Check network tab**
1. On the /_debug/inertia/ page, open browser DevTools Network tab
2. Refresh the page
3. Expected: Initial page load is a full HTML document containing `<div id="app" data-page="...">` in the response body
  </how-to-verify>
  <resume-signal>Type "approved" if all 4 tests pass, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
Phase 1 infrastructure is complete when:
1. `uv run python manage.py check` passes from scrapegrape/
2. `/_debug/inertia/` renders the InertiaTest component with props from Django
3. `http://localhost:8000/` still renders the publisher table identically
4. `http://localhost:8000/admin/` loads Django admin without issues
5. CSRF is configured (Axios defaults in main.tsx match Django's cookie/header names)
6. InertiaMiddleware is positioned after CsrfViewMiddleware in settings.py
</verification>

<success_criteria>
- INRT-01: Django middleware and settings configured (InertiaMiddleware in MIDDLEWARE, 'inertia' in INSTALLED_APPS, INERTIA_LAYOUT set)
- INRT-02: Base template has {% block inertia %} where InertiaMiddleware injects the Inertia root div
- INRT-03: Frontend entry point uses createInertiaApp with import.meta.glob('./Pages/**/*.tsx', { eager: true })
- INRT-04: CSRF configured (axios.defaults.xsrfHeaderName = "X-CSRFToken", axios.defaults.xsrfCookieName = "csrftoken")
- Existing functionality preserved (root route, admin route, publisher table)
</success_criteria>

<output>
After completion, create `.planning/phases/01-inertia-infrastructure/01-01-SUMMARY.md`
</output>
