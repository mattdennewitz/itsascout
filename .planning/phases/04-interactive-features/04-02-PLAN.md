---
phase: 04-interactive-features
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - scrapegrape/publishers/views.py
  - scrapegrape/frontend/src/Pages/Publishers/Index.tsx
autonomous: true

must_haves:
  truths:
    - "User can type in a search box and only the publishers list refreshes (not entire page)"
    - "User's table sort order and expanded rows are preserved while filtering"
    - "User's scroll position is preserved during filtering and pagination"
    - "Expensive query data (WAF reports, ToS) loads after initial page render via deferred props"
    - "User sees a loading spinner while deferred publisher data loads"
  artifacts:
    - path: "scrapegrape/publishers/views.py"
      provides: "Server-side search filtering and defer() wrapper for publishers"
      contains: "defer"
    - path: "scrapegrape/frontend/src/Pages/Publishers/Index.tsx"
      provides: "Search input with debounced partial reload and Deferred wrapper"
      contains: "Deferred"
  key_links:
    - from: "scrapegrape/frontend/src/Pages/Publishers/Index.tsx"
      to: "scrapegrape/publishers/views.py"
      via: "router.get with only: ['publishers'] for partial reload"
      pattern: "only.*publishers"
    - from: "scrapegrape/publishers/views.py"
      to: "inertia.defer"
      via: "Wrapping expensive publisher query in defer()"
      pattern: "defer\\("
    - from: "scrapegrape/frontend/src/Pages/Publishers/Index.tsx"
      to: "@inertiajs/react Deferred"
      via: "Deferred component wrapping DataTable"
      pattern: "<Deferred"
---

<objective>
Add partial reloads for table filtering and deferred props for expensive publisher data, completing VIEW-03 (lazy/deferred props) and VIEW-04 (partial reloads).

Purpose: Delivers the performance optimization layer. Partial reloads with `only: ['publishers']` prevent refetching all page props when the user filters. Deferred props delay the expensive Subquery+bulk-fetch operation until after initial page shell renders, improving perceived load time. preserveScroll and preserveState maintain user context during interactions.

Output: Modified table view with search filtering and defer(), modified Index.tsx with search input, debounced partial reload, Deferred wrapper, and loading spinner.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-interactive-features/04-RESEARCH.md
@.planning/phases/04-interactive-features/04-01-SUMMARY.md

@scrapegrape/publishers/views.py
@scrapegrape/publishers/models.py
@scrapegrape/publishers/serializers.py
@scrapegrape/frontend/src/Pages/Publishers/Index.tsx
@scrapegrape/frontend/src/datatable/table.tsx
@scrapegrape/frontend/src/datatable/columns.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-side search filtering and defer() wrapper to publisher table view</name>
  <files>
    scrapegrape/publishers/views.py
  </files>
  <action>
Modify the `table()` view function in `scrapegrape/publishers/views.py`:

**CONFIRMED: `defer()` exists in inertia-django 1.2.0.** Import path: `from inertia import defer`. Signature: `defer(callable, group="default", merge=False)`. It wraps a callable and returns a `DeferredProp` that is skipped on first load and fetched in a separate request. This is verified against the installed package source.

**1. Add search filtering support:**

Read `search = request.GET.get('search', '')` from query params.

**2. Wrap the expensive publisher loading in defer():**

Import `defer` from `inertia` at the top of the file (add to existing `from inertia import render as inertia_render` line: `from inertia import render as inertia_render, defer`).

Restructure the table() function so the entire expensive logic (Subquery annotations, in_bulk fetches, result building, serialization) is wrapped in a closure passed to `defer()`:

```python
def table(request):
    search = request.GET.get('search', '')

    def load_publishers():
        # Subqueries to get the latest related object IDs
        latest_waf = Subquery(
            WAFReport.objects.filter(publisher=OuterRef("pk"))
            .order_by("-created_at")
            .values("id")[:1]
        )
        latest_discovery = Subquery(
            TermsDiscoveryResult.objects.filter(publisher=OuterRef("pk"))
            .order_by("-created_at")
            .values("id")[:1]
        )
        latest_evaluation = Subquery(
            TermsEvaluationResult.objects.filter(publisher=OuterRef("pk"))
            .order_by("-created_at")
            .values("id")[:1]
        )

        # Annotate publishers with those latest IDs
        publishers = Publisher.objects.annotate(
            latest_waf_id=latest_waf,
            latest_discovery_id=latest_discovery,
            latest_evaluation_id=latest_evaluation,
        )

        # Apply search filter if search param exists
        if search:
            publishers = publishers.filter(name__icontains=search)

        # Get all needed related objects in bulk
        waf_reports = WAFReport.objects.in_bulk(
            publishers.values_list("latest_waf_id", flat=True)
        )
        discovery_results = TermsDiscoveryResult.objects.in_bulk(
            publishers.values_list("latest_discovery_id", flat=True)
        )
        evaluation_results = TermsEvaluationResult.objects.in_bulk(
            publishers.values_list("latest_evaluation_id", flat=True)
        )

        # Build final result
        result = []
        for publisher in publishers:
            result.append(
                {
                    "publisher": publisher,
                    "waf_report": waf_reports.get(publisher.latest_waf_id),
                    "terms_discovery": discovery_results.get(publisher.latest_discovery_id),
                    "terms_evaluation": evaluation_results.get(
                        publisher.latest_evaluation_id
                    ),
                }
            )

        serialized = PublisherWithReportsSerializer(result, many=True)
        return serialized.data

    return inertia_render(request, 'Publishers/Index', props={
        'publishers': defer(load_publishers),
    })
```

The `search` variable is captured by the closure so it's available when defer calls the function.

**3. Preserve the existing Subquery optimization pattern exactly.** Do not change the query structure -- only wrap it in the defer closure and add the search filter condition.

**IMPORTANT:** Use `uv run python manage.py check` for all Django commands.
  </action>
  <verify>
Run `cd /Users/matt/src/itsascout/scrapegrape && uv run python manage.py check` to verify no import errors. Output should include "System check identified no issues."
Run `cd /Users/matt/src/itsascout/scrapegrape && uv run python -c "from inertia import defer; print('defer imported successfully')"` to confirm defer is available.
  </verify>
  <done>
table() view supports `?search=` query param filtering publishers by name. Expensive publisher loading is wrapped in defer() for deferred loading. Subquery optimization pattern preserved unchanged inside the closure. Search filter applied after annotate but before in_bulk. Django system check passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add debounced search input, Deferred wrapper, and partial reload to Index page</name>
  <files>
    scrapegrape/frontend/src/Pages/Publishers/Index.tsx
  </files>
  <action>
Modify `scrapegrape/frontend/src/Pages/Publishers/Index.tsx`:

**1. Add imports:**
- `router, usePage` from `@inertiajs/react` (router for programmatic navigation, usePage for current URL)
- `Deferred` from `@inertiajs/react` (for deferred prop loading -- confirmed available in @inertiajs/react 2.3.14)
- `useState, useEffect` from `react`
- `Link` from `@inertiajs/react` should already be present from Plan 01 changes

**2. Add search state initialized from URL params:**

```typescript
const { url } = usePage()
const [search, setSearch] = useState(() => {
    const params = new URLSearchParams(url.split('?')[1])
    return params.get('search') || ''
})
```

**3. Add debounced partial reload effect:**

```typescript
useEffect(() => {
    const timeout = setTimeout(() => {
        router.get('/',
            { search: search || undefined },
            {
                only: ['publishers'],
                preserveScroll: true,
                preserveState: true,
                replace: true,
            }
        )
    }, 300)
    return () => clearTimeout(timeout)
}, [search])
```

- `only: ['publishers']` tells Inertia to only request the publishers prop from the server (VIEW-04 partial reload)
- `preserveState: true` keeps TanStack Table state (sorting, expanded rows)
- `preserveScroll: true` prevents scroll-to-top
- `replace: true` avoids adding a browser history entry for each keystroke
- Pass `search || undefined` so empty search doesn't add `?search=` to URL

**4. Add search input UI:**

Between the navigation links header (added in Plan 01) and the DataTable, add:
```tsx
<div className="mb-4">
    <input
        type="text"
        placeholder="Filter by name..."
        value={search}
        onChange={e => setSearch(e.target.value)}
        className="px-4 py-2 border rounded w-full max-w-md"
    />
</div>
```

**5. Wrap DataTable in Deferred component:**

Wrap the DataTable in a `<Deferred>` component for deferred prop loading (VIEW-03):
```tsx
<Deferred data="publishers" fallback={<LoadingSpinner />}>
    <DataTable columns={columns} data={publishers} />
</Deferred>
```

Add a LoadingSpinner function component in the same file:
```tsx
function LoadingSpinner() {
    return (
        <div className="flex justify-center items-center h-64">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600" />
        </div>
    )
}
```

**6. Keep the `.layout` property assignment** and all existing imports/structure. Preserve the Props interface. The final component should have: search input, Deferred-wrapped DataTable, navigation links from Plan 01, and persistent AppLayout.
  </action>
  <verify>
Run `cd /Users/matt/src/itsascout/scrapegrape/frontend && npx tsc --noEmit` to verify TypeScript compiles.
Run `cd /Users/matt/src/itsascout/scrapegrape/frontend && npm run build` to verify build succeeds.
  </verify>
  <done>
Index.tsx has a search input that triggers debounced partial reloads with `only: ['publishers']`. Search state initializes from URL params. Table state (sort, expanded rows) and scroll position preserved during filtering via preserveState and preserveScroll. DataTable wrapped in Deferred component with loading spinner fallback. TypeScript compiles. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/matt/src/itsascout/scrapegrape && uv run python manage.py check` -- Django system check passes
2. `cd /Users/matt/src/itsascout/scrapegrape/frontend && npm run build` -- Frontend builds successfully
3. Verify views.py contains `search = request.GET.get('search', '')` and filter logic
4. Verify views.py contains `defer(load_publishers)` wrapping the expensive query
5. Verify Index.tsx contains `only: ['publishers']` partial reload
6. Verify Index.tsx contains `preserveScroll: true` and `preserveState: true`
7. Verify Index.tsx contains debounced search (setTimeout with 300ms)
8. Verify Index.tsx contains `<Deferred data="publishers"` component
</verification>

<success_criteria>
- VIEW-03 delivered: Expensive publisher data loaded via defer() deferred props
- VIEW-04 delivered: Partial reloads implemented for table filtering with `only: ['publishers']`
- Search input filters publishers server-side by name
- Table state (sort, expanded rows) preserved during filtering via preserveState
- Scroll position preserved via preserveScroll
- Debounced search (300ms) with replace:true avoids history spam
- Loading spinner shown while deferred data loads
</success_criteria>

<output>
After completion, create `.planning/phases/04-interactive-features/04-02-SUMMARY.md`
</output>
