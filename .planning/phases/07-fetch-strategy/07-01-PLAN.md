---
phase: 07-fetch-strategy
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - scrapegrape/publishers/fetchers/__init__.py
  - scrapegrape/publishers/fetchers/base.py
  - scrapegrape/publishers/fetchers/exceptions.py
  - scrapegrape/publishers/fetchers/curl_cffi_fetcher.py
  - scrapegrape/publishers/fetchers/zyte_fetcher.py
  - scrapegrape/publishers/fetchers/manager.py
  - scrapegrape/publishers/tests/test_fetchers.py
  - scrapegrape/publishers/models.py
  - scrapegrape/publishers/factories.py
  - scrapegrape/publishers/migrations/0003_publisher_fetch_strategy.py
autonomous: true

must_haves:
  truths:
    - "FetchStrategyManager.fetch(url) returns FetchResult with HTML content using curl-cffi by default"
    - "When curl-cffi fails with WAF block or connection error, fetch automatically falls back to Zyte and succeeds"
    - "After a successful fetch via fallback, the working strategy is saved on the Publisher record"
    - "When a Publisher already has a saved fetch_strategy, that strategy is tried first"
    - "When all strategies fail, AllStrategiesExhausted is raised with collected errors"
  artifacts:
    - path: "scrapegrape/publishers/fetchers/base.py"
      provides: "FetchResult dataclass and BaseFetcher protocol"
      contains: "class FetchResult"
    - path: "scrapegrape/publishers/fetchers/curl_cffi_fetcher.py"
      provides: "CurlCffiFetcher with WAF detection"
      contains: "class CurlCffiFetcher"
    - path: "scrapegrape/publishers/fetchers/zyte_fetcher.py"
      provides: "ZyteFetcher wrapping Zyte API"
      contains: "class ZyteFetcher"
    - path: "scrapegrape/publishers/fetchers/manager.py"
      provides: "FetchStrategyManager with fallback and publisher memory"
      contains: "class FetchStrategyManager"
    - path: "scrapegrape/publishers/fetchers/exceptions.py"
      provides: "FetchError and AllStrategiesExhausted exceptions"
      contains: "class FetchError"
    - path: "scrapegrape/publishers/tests/test_fetchers.py"
      provides: "Test suite for all fetcher components"
      min_lines: 100
  key_links:
    - from: "scrapegrape/publishers/fetchers/manager.py"
      to: "scrapegrape/publishers/models.py"
      via: "publisher.fetch_strategy field read/write"
      pattern: "publisher\\.fetch_strategy"
    - from: "scrapegrape/publishers/fetchers/manager.py"
      to: "scrapegrape/publishers/fetchers/curl_cffi_fetcher.py"
      via: "strategy dict lookup and .fetch() call"
      pattern: "_fetchers\\[.*\\]\\.fetch"
    - from: "scrapegrape/publishers/fetchers/manager.py"
      to: "scrapegrape/publishers/fetchers/zyte_fetcher.py"
      via: "strategy dict lookup and .fetch() call"
      pattern: "_fetchers\\[.*\\]\\.fetch"
---

<objective>
Implement a fetch strategy manager with curl-cffi (browser TLS impersonation) as default, Zyte API as fallback, and per-publisher strategy memory -- all driven by TDD.

Purpose: Pipeline steps need a single entry point to fetch any page. The strategy manager handles WAF detection, automatic fallback, and remembers what works per publisher to minimize Zyte API costs.

Output: Working, tested fetch strategy module with FetchStrategyManager, CurlCffiFetcher, ZyteFetcher, custom exceptions, and a Publisher model migration for the fetch_strategy field. All verified by a comprehensive test suite.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-fetch-strategy/07-RESEARCH.md
@.planning/phases/06-infrastructure-models/06-02-SUMMARY.md

# Existing code to reference
@scrapegrape/publishers/models.py
@scrapegrape/publishers/factories.py
@scrapegrape/conftest.py
@scrapegrape/publishers/tests/test_models.py
@scrapegrape/ingestion/services.py
</context>

<feature>
  <name>Fetch Strategy Manager with curl-cffi, Zyte fallback, and publisher memory</name>
  <files>
    scrapegrape/publishers/fetchers/__init__.py
    scrapegrape/publishers/fetchers/base.py
    scrapegrape/publishers/fetchers/exceptions.py
    scrapegrape/publishers/fetchers/curl_cffi_fetcher.py
    scrapegrape/publishers/fetchers/zyte_fetcher.py
    scrapegrape/publishers/fetchers/manager.py
    scrapegrape/publishers/tests/test_fetchers.py
    scrapegrape/publishers/models.py
    scrapegrape/publishers/factories.py
    scrapegrape/publishers/migrations/0003_publisher_fetch_strategy.py
  </files>
  <behavior>
    The fetch strategy module provides a FetchStrategyManager that fetches URLs through a chain of strategies with automatic fallback and per-publisher memory.

    Core behaviors (test cases):

    **CurlCffiFetcher:**
    - fetch(url) returns FetchResult with html, status_code=200, strategy_used="curl_cffi"
    - 403 response raises FetchError with strategy="curl_cffi"
    - Response containing WAF signatures ("checking your browser", "cloudflare", "access denied", "just a moment", "cf-browser-verification", "ray id") on 200 status raises FetchError
    - Connection error (RequestException) raises FetchError with strategy="curl_cffi"

    **ZyteFetcher:**
    - fetch(url) returns FetchResult with decoded HTML, status_code=200, strategy_used="zyte"
    - Missing ZYTE_API_KEY raises FetchError with strategy="zyte"
    - Zyte API error (RequestException) raises FetchError with strategy="zyte"

    **FetchStrategyManager:**
    - fetch(url) with no publisher tries curl_cffi first, returns result on success
    - fetch(url) with curl_cffi failing falls back to zyte, returns zyte result
    - fetch(url, publisher) with empty fetch_strategy tries curl_cffi first (default order)
    - fetch(url, publisher) with fetch_strategy="zyte" tries zyte first
    - When fallback succeeds, publisher.fetch_strategy is updated to the working strategy
    - When strategy matches what's already saved, no database write occurs
    - When all strategies fail, raises AllStrategiesExhausted with collected errors

    **Publisher model:**
    - fetch_strategy field exists with CharField(max_length=20, blank=True, default="")
    - fetch_strategy choices include "", "curl_cffi", "zyte"
    - PublisherFactory supports fetch_strategy parameter
  </behavior>
  <implementation>
    After tests are written and failing (RED), implement in this order:

    1. Install curl-cffi: `uv add curl-cffi` (in scrapegrape/ directory where pyproject.toml lives)

    2. Create exceptions.py with FetchError(message, strategy) and AllStrategiesExhausted(message, errors)

    3. Create base.py with FetchResult dataclass (html: str, status_code: int, strategy_used: str, url: str) and BaseFetcher Protocol (name: str, fetch(url) -> FetchResult)

    4. Create curl_cffi_fetcher.py:
       - Import curl_cffi.requests as curl_requests
       - WAF_BLOCK_SIGNATURES constant list: ["checking your browser", "cloudflare", "access denied", "just a moment", "cf-browser-verification", "ray id"]
       - CurlCffiFetcher with name="curl_cffi", __init__(timeout=30.0, impersonate="chrome")
       - fetch() uses curl_requests.get(url, impersonate=self.impersonate, timeout=self.timeout)
       - Catches curl_cffi.requests.exceptions.RequestException -> FetchError
       - Checks status 403 OR _is_waf_block(body) -> FetchError
       - Calls response.raise_for_status() for other non-200 codes -> catch HTTPError -> FetchError
       - Returns FetchResult on success

    5. Create zyte_fetcher.py:
       - ZyteFetcher with name="zyte", __init__(timeout=30.0)
       - fetch() reads ZYTE_API_KEY from os.getenv, raises FetchError if missing
       - POST to https://api.zyte.com/v1/extract with auth=(api_key, ""), json={"url": url, "httpResponseBody": True}
       - Catches requests.RequestException -> FetchError
       - b64decode response body, return FetchResult

    6. Create manager.py:
       - FetchStrategyManager with STRATEGIES = ["curl_cffi", "zyte"]
       - __init__ creates dict of fetcher instances
       - fetch(url, publisher=None) -> FetchResult
       - _ordered_strategies(publisher) returns list with publisher.fetch_strategy first if set
       - Iterates strategies, catches FetchError, logs warning, continues
       - On success: if publisher and strategy changed, save(update_fields=["fetch_strategy"])
       - On all fail: raise AllStrategiesExhausted with collected errors

    7. Create __init__.py exporting FetchStrategyManager, FetchResult, FetchError, AllStrategiesExhausted

    8. Add fetch_strategy field to Publisher model + migration

    9. Update PublisherFactory to include fetch_strategy="" default
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for fetchers, manager, and publisher migration</name>
  <files>
    scrapegrape/publishers/tests/test_fetchers.py
    scrapegrape/publishers/fetchers/__init__.py
  </files>
  <action>
    Create `scrapegrape/publishers/fetchers/__init__.py` as an empty file (needed so test imports don't fail at module level).

    Create `scrapegrape/publishers/tests/test_fetchers.py` with the following test classes. All tests use monkeypatch to mock HTTP calls -- no real network requests.

    **TestCurlCffiFetcher:**
    - `test_successful_fetch`: Monkeypatch `publishers.fetchers.curl_cffi_fetcher.curl_requests.get` to return a mock response (status_code=200, text="<html>Hello</html>"). Assert result.html, result.strategy_used == "curl_cffi", result.status_code == 200.
    - `test_403_raises_fetch_error`: Mock returns status_code=403, text="Access Denied". Assert FetchError raised with "WAF block" in message.
    - `test_waf_signature_on_200_raises_fetch_error`: Mock returns status_code=200, text containing "checking your browser". Assert FetchError raised.
    - `test_connection_error_raises_fetch_error`: Monkeypatch to raise RequestException. Assert FetchError raised with strategy="curl_cffi".

    **TestZyteFetcher:**
    - `test_successful_fetch`: Monkeypatch `os.getenv` to return "fake-key" for ZYTE_API_KEY. Monkeypatch `publishers.fetchers.zyte_fetcher.requests.post` to return mock response (status_code=200, json={"httpResponseBody": base64("<html>Zyte</html>")}). Assert result.html == "<html>Zyte</html>", result.strategy_used == "zyte".
    - `test_missing_api_key_raises_fetch_error`: Monkeypatch `os.getenv` to return None. Assert FetchError raised with "ZYTE_API_KEY" in message.
    - `test_api_error_raises_fetch_error`: Monkeypatch os.getenv to return "fake-key". Monkeypatch requests.post to raise requests.RequestException. Assert FetchError raised with strategy="zyte".

    **TestFetchStrategyManager (all @pytest.mark.django_db):**
    - `test_default_uses_curl_cffi_first`: Monkeypatch both fetchers. curl_cffi succeeds. Assert result.strategy_used == "curl_cffi". Assert zyte fetcher was NOT called (use a call tracker).
    - `test_falls_back_to_zyte_on_curl_cffi_failure`: Monkeypatch curl_cffi to raise FetchError, zyte to succeed. Assert result.strategy_used == "zyte".
    - `test_remembers_working_strategy_on_publisher`: Create publisher with fetch_strategy="". Monkeypatch curl_cffi to fail, zyte to succeed. Call fetch with publisher. Refresh from DB. Assert publisher.fetch_strategy == "zyte".
    - `test_no_db_write_when_strategy_unchanged`: Create publisher with fetch_strategy="curl_cffi". Monkeypatch curl_cffi to succeed. Call fetch with publisher. Assert publisher.save was NOT called (or verify with a query count check -- `django.test.utils.override_settings` or assertNumQueries approach).
    - `test_uses_remembered_strategy_first`: Create publisher with fetch_strategy="zyte". Monkeypatch both fetchers with call trackers. Zyte succeeds immediately. Assert only zyte was called.
    - `test_all_strategies_exhausted`: Monkeypatch both fetchers to raise FetchError. Assert AllStrategiesExhausted raised.
    - `test_fetch_without_publisher_works`: Monkeypatch curl_cffi to succeed. Call fetch(url) with no publisher arg. Assert result returned (no crash on publisher=None).

    **TestPublisherFetchStrategy (@pytest.mark.django_db):**
    - `test_fetch_strategy_field_exists`: Create publisher via factory. Assert hasattr(publisher, "fetch_strategy"). Assert publisher.fetch_strategy == "".
    - `test_fetch_strategy_choices`: Assert Publisher._meta.get_field("fetch_strategy").choices contains the three options.

    After writing tests, run `uv run pytest scrapegrape/publishers/tests/test_fetchers.py -v`. Tests should FAIL (RED) because no implementation exists yet. Expect ImportError or ModuleNotFoundError for the fetcher modules.

    Commit with message: `test(07-01): add failing tests for fetch strategy manager, fetchers, and publisher memory`
  </action>
  <verify>
    `uv run pytest scrapegrape/publishers/tests/test_fetchers.py -v` runs and ALL tests fail (ImportError or assertion failures). The test file parses without syntax errors. Run from `scrapegrape/` directory.
  </verify>
  <done>Test file exists with 15+ test methods covering CurlCffiFetcher, ZyteFetcher, FetchStrategyManager, and Publisher fetch_strategy field. All tests fail because implementation does not exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Install curl-cffi, implement fetchers, manager, migration, and pass all tests</name>
  <files>
    scrapegrape/publishers/fetchers/__init__.py
    scrapegrape/publishers/fetchers/base.py
    scrapegrape/publishers/fetchers/exceptions.py
    scrapegrape/publishers/fetchers/curl_cffi_fetcher.py
    scrapegrape/publishers/fetchers/zyte_fetcher.py
    scrapegrape/publishers/fetchers/manager.py
    scrapegrape/publishers/models.py
    scrapegrape/publishers/factories.py
    scrapegrape/publishers/migrations/0003_publisher_fetch_strategy.py
  </files>
  <action>
    **Step 1: Install curl-cffi**

    Run from `scrapegrape/` directory (where pyproject.toml lives):
    ```bash
    cd scrapegrape && uv add curl-cffi
    ```
    Verify import works: `uv run python -c "from curl_cffi import requests; print('ok')"`

    **Step 2: Create exceptions.py**

    `scrapegrape/publishers/fetchers/exceptions.py`:
    - `FetchError(Exception)` with `__init__(self, message: str, strategy: str)` storing `self.strategy`
    - `AllStrategiesExhausted(Exception)` with `__init__(self, message: str, errors: list[FetchError] | None = None)` storing `self.errors`

    **Step 3: Create base.py**

    `scrapegrape/publishers/fetchers/base.py`:
    - `from __future__ import annotations`
    - `@dataclass FetchResult` with `html: str, status_code: int, strategy_used: str, url: str`
    - `class BaseFetcher(Protocol)` with `name: str` and `def fetch(self, url: str) -> FetchResult`

    **Step 4: Create curl_cffi_fetcher.py**

    `scrapegrape/publishers/fetchers/curl_cffi_fetcher.py`:
    - Import `curl_cffi.requests as curl_requests`
    - `WAF_BLOCK_SIGNATURES` list: `["checking your browser", "cloudflare", "access denied", "just a moment", "cf-browser-verification", "ray id"]`
    - `CurlCffiFetcher` class with `name = "curl_cffi"`
    - `__init__(self, timeout=30.0, impersonate="chrome")`
    - `fetch(self, url)`:
      - try: `curl_requests.get(url, impersonate=self.impersonate, timeout=self.timeout)`
      - except `curl_requests.exceptions.RequestException` -> raise `FetchError(..., strategy="curl_cffi")`
      - if status_code == 403 or `_is_waf_block(response.text)` -> raise `FetchError("WAF block detected...", strategy="curl_cffi")`
      - try: `response.raise_for_status()` except -> raise `FetchError(..., strategy="curl_cffi")`
      - return `FetchResult(html=response.text, status_code=response.status_code, strategy_used=self.name, url=url)`
    - `_is_waf_block(self, body)`: lowercase body, check if any signature in WAF_BLOCK_SIGNATURES matches

    **Step 5: Create zyte_fetcher.py**

    `scrapegrape/publishers/fetchers/zyte_fetcher.py`:
    - Import `os`, `requests`, `b64decode`
    - `ZyteFetcher` class with `name = "zyte"`
    - `__init__(self, timeout=30.0)`
    - `fetch(self, url)`:
      - `api_key = os.getenv("ZYTE_API_KEY")` -- raise `FetchError("ZYTE_API_KEY not set", strategy="zyte")` if missing
      - try: `requests.post("https://api.zyte.com/v1/extract", auth=(api_key, ""), json={"url": url, "httpResponseBody": True}, timeout=self.timeout)`
      - `api_response.raise_for_status()`
      - except `requests.RequestException` -> raise `FetchError(..., strategy="zyte")`
      - `body = b64decode(api_response.json()["httpResponseBody"]).decode("utf-8")`
      - return `FetchResult(html=body, status_code=200, strategy_used=self.name, url=url)`

    **Step 6: Create manager.py**

    `scrapegrape/publishers/fetchers/manager.py`:
    - Import loguru logger, Publisher model (TYPE_CHECKING import to avoid circular)
    - `FetchStrategyManager` with `STRATEGIES = ["curl_cffi", "zyte"]`
    - `__init__` creates `self._fetchers` dict mapping names to instances
    - `fetch(self, url: str, publisher=None) -> FetchResult`:
      - Get ordered strategies via `_ordered_strategies(publisher)`
      - Loop through strategies, try each fetcher.fetch(url)
      - On success: if publisher and `publisher.fetch_strategy != strategy_name`, update and `publisher.save(update_fields=["fetch_strategy"])`
      - On FetchError: log warning, collect error, continue
      - After loop: raise `AllStrategiesExhausted(f"All strategies exhausted for {url}", errors=errors)`
    - `_ordered_strategies(self, publisher)`: if publisher has non-empty fetch_strategy, put it first, then remaining

    **Step 7: Create __init__.py**

    `scrapegrape/publishers/fetchers/__init__.py`:
    - Export `FetchStrategyManager`, `FetchResult`, `FetchError`, `AllStrategiesExhausted`

    **Step 8: Add fetch_strategy to Publisher model**

    In `scrapegrape/publishers/models.py`, add to Publisher class:
    ```python
    FETCH_STRATEGY_CHOICES = [
        ("", "Auto (no preference)"),
        ("curl_cffi", "curl-cffi"),
        ("zyte", "Zyte API"),
    ]
    ```
    And the field:
    ```python
    fetch_strategy = models.CharField(
        max_length=20,
        blank=True,
        default="",
        choices=FETCH_STRATEGY_CHOICES,
    )
    ```
    Then run: `cd scrapegrape && uv run python manage.py makemigrations publishers`

    **Step 9: Update PublisherFactory**

    In `scrapegrape/publishers/factories.py`, add `fetch_strategy = ""` to PublisherFactory.

    **Step 10: Run all tests**

    ```bash
    cd scrapegrape && uv run pytest scrapegrape/publishers/tests/test_fetchers.py -v
    ```
    All tests must pass. Then run the full suite:
    ```bash
    cd scrapegrape && uv run pytest scrapegrape/ -v
    ```
    All 29 existing tests + new fetcher tests must pass.

    Commit with message: `feat(07-01): implement fetch strategy manager with curl-cffi, Zyte fallback, and publisher memory`
  </action>
  <verify>
    1. `cd scrapegrape && uv run python -c "from curl_cffi import requests; print('ok')"` prints "ok"
    2. `cd scrapegrape && uv run pytest scrapegrape/publishers/tests/test_fetchers.py -v` -- all tests pass
    3. `cd scrapegrape && uv run pytest scrapegrape/ -v` -- all tests pass (existing 29 + new)
    4. `cd scrapegrape && uv run python manage.py migrate --check` -- no unapplied migrations
    5. `cd scrapegrape && uv run python -c "from publishers.fetchers import FetchStrategyManager, FetchResult, FetchError, AllStrategiesExhausted; print('imports ok')"` -- all exports work
  </verify>
  <done>curl-cffi installed. All fetcher modules implemented. Publisher model has fetch_strategy field with migration applied. Full test suite passes (existing + new fetcher tests). FetchStrategyManager, FetchResult, FetchError, AllStrategiesExhausted importable from publishers.fetchers.</done>
</task>

</tasks>

<verification>
1. `uv run pytest scrapegrape/ -v` -- full test suite passes with 0 failures
2. `uv run python manage.py migrate --check` -- no unapplied migrations
3. All fetcher modules importable: `from publishers.fetchers import FetchStrategyManager, FetchResult, FetchError, AllStrategiesExhausted`
4. Publisher model has fetch_strategy field: `Publisher._meta.get_field("fetch_strategy")`
5. Test coverage: CurlCffiFetcher (success, 403, WAF signature, connection error), ZyteFetcher (success, missing key, API error), Manager (default order, fallback, memory save, no unnecessary save, remembered order, all-exhausted, no-publisher)
</verification>

<success_criteria>
- FetchStrategyManager.fetch(url) returns valid FetchResult using curl-cffi as default strategy
- When curl-cffi fails, automatic fallback to Zyte succeeds and returns valid FetchResult
- Working strategy is persisted on Publisher.fetch_strategy only when it changes
- Remembered strategy is tried first on subsequent fetches for the same publisher
- AllStrategiesExhausted raised when both strategies fail
- All tests pass including existing 29 model/sanitizer tests
- No real HTTP calls in any test (all monkeypatched)
</success_criteria>

<output>
After completion, create `.planning/phases/07-fetch-strategy/07-01-SUMMARY.md`
</output>
