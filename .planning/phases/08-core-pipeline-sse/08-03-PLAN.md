---
phase: 08-core-pipeline-sse
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - scrapegrape/frontend/src/Pages/Jobs/Show.tsx
  - scrapegrape/frontend/src/Pages/Publishers/Index.tsx
autonomous: true

must_haves:
  truths:
    - "Jobs/Show page displays job status, publisher info, and pipeline step cards"
    - "Jobs/Show opens an EventSource connection to /api/jobs/<uuid>/stream when job is pending or running"
    - "As SSE events arrive, step cards update from pending to started to completed/failed/skipped"
    - "EventSource closes on terminal 'done' event and does not auto-reconnect"
    - "Publishers/Index page has a URL input form that POSTs to /submit"
    - "Completed jobs render all step results from initial props (no SSE needed)"
  artifacts:
    - path: "scrapegrape/frontend/src/Pages/Jobs/Show.tsx"
      provides: "Streaming results page with EventSource and progress cards"
      contains: "EventSource"
    - path: "scrapegrape/frontend/src/Pages/Publishers/Index.tsx"
      provides: "URL submission form added above publisher table"
      contains: "/submit"
  key_links:
    - from: "scrapegrape/frontend/src/Pages/Jobs/Show.tsx"
      to: "/api/jobs/<uuid>/stream"
      via: "EventSource connection"
      pattern: "new EventSource"
    - from: "scrapegrape/frontend/src/Pages/Publishers/Index.tsx"
      to: "/submit"
      via: "form POST action"
      pattern: "action.*submit"
---

<objective>
Create the Jobs/Show.tsx page with EventSource-driven progress cards and add a URL input form to the Publishers/Index.tsx homepage.

Purpose: This is the user-facing frontend for the core pipeline. Users paste a URL on the homepage and are redirected to a job page where they watch progress in real time as cards update via SSE.

Output: Two React page components -- streaming job results page and homepage with URL input.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-core-pipeline-sse/08-RESEARCH.md
@.planning/phases/08-core-pipeline-sse/08-01-SUMMARY.md

# Key existing code
@scrapegrape/frontend/src/Pages/Publishers/Index.tsx
@scrapegrape/frontend/src/Layouts/AppLayout.tsx
@scrapegrape/frontend/src/main.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jobs/Show.tsx with EventSource progress cards</name>
  <files>
    scrapegrape/frontend/src/Pages/Jobs/Show.tsx
  </files>
  <action>
Create directory `scrapegrape/frontend/src/Pages/Jobs/` and the `Show.tsx` page component.

**Type definitions:**
```typescript
interface PipelineEvent {
    step: string
    status: 'started' | 'completed' | 'failed' | 'skipped'
    data: Record<string, unknown>
}

interface JobProps {
    job: {
        id: string
        status: string
        canonical_url: string
        submitted_url: string
        publisher_name: string
        publisher_domain: string
        waf_result: Record<string, unknown> | null
        tos_result: Record<string, unknown> | null
        created_at: string
    }
}
```

**Pipeline steps config:**
Define an array of step definitions for rendering cards:
```typescript
const PIPELINE_STEPS = [
    { key: 'publisher_resolution', label: 'Publisher Resolution', icon: '1' },
    { key: 'waf', label: 'WAF Detection', icon: '2' },
    { key: 'tos_discovery', label: 'ToS Discovery', icon: '3' },
    { key: 'tos_evaluation', label: 'ToS Evaluation', icon: '4' },
]
```

**Component logic:**
- State: `events` (PipelineEvent[]), `stepStatuses` (Record<string, PipelineEvent>), `connected` (boolean).
- On mount, if `job.status` is "completed" or "failed", render the final state from props (no EventSource needed).
- If `job.status` is "pending" or "running":
  - Create `new EventSource(\`/api/jobs/${job.id}/stream\`)`.
  - `onopen`: set `connected = true`.
  - `onmessage`: parse event data as JSON PipelineEvent. Update `stepStatuses` map (keyed by step name). Append to `events` array.
  - `addEventListener('done', ...)`: call `es.close()`, set `connected = false`. Optionally, after a small delay, reload the page via `router.reload()` (Inertia) to get final props from the server.
  - `onerror`: set `connected = false` (EventSource will auto-reconnect for non-terminal errors).
  - Return cleanup function: `es.close()`.

**Rendering:**
- Page header: Show `job.canonical_url` (truncated), `job.publisher_name`, and a status badge (pending=yellow, running=blue, completed=green, failed=red).
- Connection indicator: Small dot (green when connected, gray otherwise). Only show when job is active.
- Step cards: Map over `PIPELINE_STEPS`. For each step:
  - Look up status in `stepStatuses[step.key]`.
  - If completed: green border/bg, show step data (e.g., "Cloudflare detected" for WAF, "ToS found at ..." for discovery).
  - If started: blue border/bg with pulsing animation (`animate-pulse`).
  - If failed: red border/bg with error message.
  - If skipped: gray border/bg with "Skipped (publisher recently checked)".
  - If no status yet (pending): gray border, dimmed text.
- For completed jobs (rendered from props, no SSE): build `stepStatuses` from `job.waf_result` and `job.tos_result` on initial render. Show publisher_resolution as always completed. If `job.waf_result` exists, show WAF as completed with its data. Same for tos_result.

**Layout:** Assign `AppLayout` as the layout using the `.layout` pattern:
```typescript
Show.layout = (page: React.ReactNode) => <AppLayout>{page}</AppLayout>
```

Use Tailwind classes for all styling. No additional CSS or component library needed. Keep the UI functional (cards, borders, text) -- not over-designed. This is Phase 8 (core functionality), not Phase 11 (report card polish).
  </action>
  <verify>
- `ls scrapegrape/frontend/src/Pages/Jobs/Show.tsx` -- file exists
- `cd scrapegrape/frontend && npx tsc --noEmit` -- TypeScript compiles without errors (if tsconfig exists) OR `npx vite build --mode development 2>&1 | head -20` -- no build errors
  </verify>
  <done>Jobs/Show.tsx page exists with EventSource integration, progress step cards that update in real time, completed job rendering from props, proper cleanup on unmount, and AppLayout wrapper.</done>
</task>

<task type="auto">
  <name>Task 2: Add URL input form to Publishers/Index.tsx homepage</name>
  <files>
    scrapegrape/frontend/src/Pages/Publishers/Index.tsx
  </files>
  <action>
Edit the existing `Publishers/Index.tsx` to add a URL submission form ABOVE the existing publisher table. Do NOT remove or modify the existing table code.

**Add a URL input section at the top of the page content** (inside the main container, before the publisher table):

```tsx
<div className="bg-white rounded-lg shadow-sm border p-6 mb-6">
    <h2 className="text-lg font-semibold text-gray-900 mb-2">Analyze a URL</h2>
    <p className="text-sm text-gray-500 mb-4">
        Paste a URL to get a comprehensive scraping report card
    </p>
    <form action="/submit" method="POST" className="flex gap-3">
        <input type="hidden" name="csrfmiddlewaretoken" value={csrfToken} />
        <input
            type="url"
            name="url"
            placeholder="https://example.com/article"
            required
            className="flex-1 rounded-md border border-gray-300 px-4 py-2 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
        />
        <button
            type="submit"
            className="bg-blue-600 text-white px-6 py-2 rounded-md text-sm font-medium hover:bg-blue-700 transition-colors"
        >
            Analyze
        </button>
    </form>
</div>
```

**CSRF token:** Get the CSRF token from the cookie. Use a small helper or read it from `document.cookie`:
```typescript
function getCsrfToken(): string {
    const match = document.cookie.match(/csrftoken=([^;]+)/)
    return match ? match[1] : ''
}
```
Call this inside the component: `const csrfToken = getCsrfToken()`.

**Important:** The form uses a standard HTML form POST (action="/submit", method="POST") -- NOT Inertia's `useForm`. This is intentional because the submit endpoint redirects to `/jobs/<uuid>` which is a new Inertia page. A standard form submission triggers a full navigation, which Inertia intercepts and handles as an SPA transition.

**Do NOT modify** the existing table rendering, search functionality, defer loading, or any other existing code in this component. Only ADD the URL input section at the top.
  </action>
  <verify>
- Visually inspect the file to confirm the URL input form is above the table
- `cd scrapegrape/frontend && npx vite build --mode development 2>&1 | head -20` -- no build errors
  </verify>
  <done>Publishers/Index.tsx has a prominent URL input form above the publisher table. Form POSTs to /submit with CSRF token. Existing table functionality is unchanged.</done>
</task>

</tasks>

<verification>
1. `ls scrapegrape/frontend/src/Pages/Jobs/Show.tsx` -- file exists
2. Vite build succeeds without errors
3. Publishers/Index.tsx contains both the URL input form and the existing publisher table
4. Jobs/Show.tsx contains EventSource usage and step card rendering
5. Both pages use AppLayout
</verification>

<success_criteria>
- Jobs/Show page renders pipeline progress with step cards
- EventSource connects to SSE endpoint and updates cards in real time
- EventSource properly closes on terminal events
- Completed jobs render from props without SSE
- Homepage has a prominent URL input that submits to /submit
- Publisher table continues working identically
- Vite builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-core-pipeline-sse/08-03-SUMMARY.md`
</output>
